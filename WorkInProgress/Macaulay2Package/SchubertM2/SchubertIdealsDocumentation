--------------------------------------------------
-- NOTES:

-- OUR FIELD: K (can be any field).

-- COMPLETE FLAG IN K^n: Represented by an nxn invertible matrix F, whose column spans give the corresponding flag.

-- FLAG SHAPE: A list {a_1,...,a_s,n} (1 <= a_1 < ... < a_s < n) representing the flag variety that only consists of flags given by a_1-dimensional
-- subspaces contained in ... contained in a_s-dimensional subspaces in K^n. With this terminology, complete flags have shape {1,2,...,n-1,n}.

-- SCHUBERT CONDITION (minimal length coset representative of element of a Weyl group): Represented by a "partial permutation", a list of size a_s
-- of increasing elements of [n], except for possible descents in positions a_1,...,a_s (index starting at 1). These partial permutations represent a
-- unique permutation in S_n, which is obtained by appending the remaining elements of [n] in increasing order.

--------------------------------------------------
-- dimToCodim --

-- Function: 
-- Takes in a flag shape and Schubert condition for that shape, returning the "dual Schubert condition" of the same shape. Schubert conditions commonly 
-- have two conventions (dimension convention and codimension convention). A condition in dimension convention represents the same object as its dual
-- condition in codimension convention, and vice versa. Dimension convention makes the definition of Schubert varieities and their Stiefel coordinates
-- much more tractable, but codimension convention is what we actually want to use in this package, primarily because it then matches the cohomology
-- calculations for intersection theory. Also, the length of a permutation giving codimension is an invariant when embedding smaller flag varieties 
-- and their Schubert subvarieties into larger flag varieties, while dimension is not. 

-- Inputs: 
-- (1) flagshape, a list {a_1,...,a_s,n}.
-- (2) alpha, a list {alpha_1,...,alpha_(a_s)} giving a Schubert condition of that shape.

-- Outputs:
-- (1) alphadual, another list {alpha_1^(hat),...,alpha_(a_s)^(hat)} of the same size as alpha, representing the dual Schubert condition to alpha
--                in the flag variety of shape {a_1,...,a_s,n}.

-- Tests: 
-- (1) dimToCodim({2,4},{3,4}) should give {1,2} (the dense cell goes to the point)
-- (2) dimToCodim({2,4},{1,4}) should give {1,4} (self-dual example)
-- (3) dimToCodim({3,17,21},{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}) should give {19, 20, 21, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}
--     (just to have a more complicated example)

------------------------------
-- typeAStiefelCoords --

-- Function: 
-- Takes in a flag shape and Schubert condition for that shape, along with a coefficient field K, and returns the Stiefel coordinates for the 
-- correspoding type A Schubert variety. These Stiefel coordinates are specific local coordinates for the (smooth) points of the Schubert variety
-- with respect to how that variety intersects the standard opposite flag (reverse identity on anti-diagonal, all other entries zero). In particular,
-- these coordinates are given in terms of a matrix with identity matrix in rows indexed by the Schubert condition, and with zeros above and to the 
-- left of the leading ones. Here we use codimension convention, and index rows from top to bottom.

-- Inputs:
-- (1) flagshape, a list {a_1,...,a_s,n}.
-- (2) alpha, a list {alpha_1,...,alpha_(a_s)} giving a Schubert condition of that shape.
-- (3) K, a coefficient field for our polynomial ring.

-- Outputs:
-- (1) M, a matrix giving Stiefel coordinates for the Schubert variety given by flagshape and alpha.
-- (2) R, a polynomial ring whose generators are the intdeterminates in M, with number of generators the dimension of the Schubert variety.

-- Helper Function: splitPermutation
-- (splits alpha up into a list of lists determined by flagshape)

----- NOTE: "exteriorPower(k,M)" will compute the Plucker vector for us -----
----- NOTE: "subsets({1..n},k)" will compute all k element subsets of {1,...,n} for us, 
-----             IN THE SAME ORDERING as the Plucker vector from "exteriorPower" above -----
      
-- Tests:
-- splitPermutation({2,3,6,9},{7,8,4,1,2,3}) should give {{7,8},{4},{1,2,3}}
-- (All big cells in 4-space)
-- (1) typeAStiefelCoords({1,4},{1},QQ)
-- (2) typeAStiefelCoords({2,4},{1,2},QQ)
-- (3) typeAStiefelCoords({1,2,4},{1,2},QQ)
-- (4) typeAStiefelCoords({3,4},{1,2,3},QQ)
-- (5) typeAStiefelCoords({1,3,4},{1,2,3},QQ)
-- (6) typeAStiefelCoords({2,3,4},{1,2,3},QQ)
-- (7) typeAStiefelCoords({1,2,3,4},{1,2,3},QQ)
-- (8) typeAStiefelCoords({4,4},{1,2,3,4},QQ)

------------------------------
-- notGreaterThan --

-- Function: Determines whether a partial permutation, beta, is NOT greater than or equal to another partial permutation, alpha, in the Bruhat
-- partial order. If beta is NOT greater than or equal to alpha, the function returns "true". Otherwise, the function returns "false".

-- Tests:
-- notGreaterThan({1,2},{3,4}) returns "true"
-- notGreaterThan({3,4},{1,2}) returns "false"
-- notGreaterThan({1,4},{2,3}) returns "true" (incomparable example)
-- notGreaterThan({1,2},{1,2}) returns "false"

------------------------------
-- allNotGreaterThan --

-- Function: For a fixed partial permutation, alpha, lists all other partial permutations of the same shape as alpha that are NOT greater than
-- alpha in the Bruhat partial order.

-- Tests:
-- (All examples in G(2,4))
-- allNotGreaterThan({1,2},4) returns "{}"
-- allNotGreaterThan({1,3},4) returns "{{1,2}}"
-- allNotGreaterThan({1,4},4) returns "{{1,2},{1,3},{2,3}}"
-- allNotGreaterThan({2,3},4) returns "{{1,2},{1,3},{1,4}}"
-- allNotGreaterThan({2,4},4) returns "{{1,2},{1,3},{2,3},{1,4}}"
-- allNotGreaterThan({3,4},4) returns "{{1,2},{1,3},{2,3},{1,4},{2,4}}"
------------------------------
-- cauchyBinetCoefficients --

-- Function: 
------------------------------

-- Test: polyRep(bubbleSort({1,4,3,2}),QQ[a,b,c,d]) 
-- Returns: a^2*b + a*b^2  + a^2*c + a*b*c + b^2*c

-- Test for printing out all permutations at once:
-- for perm in permutations({1,2,3,4}) do(
--       print(perm);
--       print(polyRep(bubbleSort(perm),QQ[a,b,c,d])))
-- Returns: All 24 Schubert polynomials for S_4

-- NOTE: Currently Struggles if answer is 0, need an "if, then" statement to rectify this.
-- Tests: elementarySymmetricIdeal(4) (sets up S and I)
--       intA({{2,1,3,4},{3,4,2,1}},S,I) (gives 1)
--       intA({{2,1,3,4},{4,3,1,2}},S,I) (gives error, should be 0)
--       intA({{2,1,3,4},{1,3,2,4},{1,3,2,4},{1,3,2,4},{1,3,2,4},{1,2,4,3}},S,I) (gives 2)

---- NOTE: all polyRepB/C/D methods require R to be in terms of variables y_1..y_n, not a,b,c, etc. FIX THIS! ---
