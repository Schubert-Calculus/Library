------------------------------------
-- typeAStiefelCoords
------------------------------------
-- Computes Stiefel Coordinates for a Type A Flag Variety (including Grassmannians as a special case)
-- Inputs: k, the dimension of the largest proper subspace in our flag variety (if we want 2 planes in 4 planes in 6 space, k = 4)
--            (do I need to specify the other subspaces instead, or is this enough? If no change, how do I really know based off of
--             alpha which flag variety I'm working in? For example, if k = 4, n = 6, and alpha = {1,2,3,4}, how would I know whether
--             I am in 2 planes in 4 planes in 6 space vs just 4 planes in 6 space, since there are no descents? This shouldn't affect
--             any of the functionality of my code below, but I was just wondering.)
--         n, dimension of the ambient affine space (if we want 2 planes in 4 planes in 6 space, n = 6)
--         alpha, a k element subset of {1,...,n} (descents of alpha imply which flag variety we're working in: 
--                if we want 2 planes in 4 planes in 6 space, alpha_1 < alpha_2 and alpha_3 < alpha_4, but perhaps alpha_2 > alpha_3)
--         K, coefficient ring (for example QQ)
-- Outputs: M, the matrix of Stiefel coordinates
--          R, the ring of variables used in M (right now, actually more variables than that - can fix?)
           
typeAStiefelCoords = method()
typeAStiefelCoords(ZZ,ZZ,List,Ring) := (k,n,alpha,K) -> (
-- Define ring of variables
     S = K[y_(1,1)..y_(n,k)];
-- Define matrix of correct size (and over the correct ring) that we can manipulate
     M = mutableMatrix(R,n,k);
-- Set leading ones in kxk identity submatrix with rows indexed by alpha
     for i from 1 to k do M_(alpha_(i-1)-1,i-1) = 1;
-- Set variables above the leading 1's
     for j from 1 to k do
     for i from 1 to alpha_(j-1)-1 do M_(i-1,j-1) = y_(i,j);
-- Set to 0 all entries below and to the right of leading 1's
     for i from 1 to k do
     for j from i+1 to k do M_(alpha_(i-1)-1,j-1) = 0;
     M = matrix M;
     R = K[support M];
     M = sub(M,R);
-- Make matrix non-mutable, and return Stiefel coordinates and ring
     {M, R})
     
----- NOTE: "exteriorPower(k,M)" will compute the Plucker vector for us -----
----- NOTE: "subsets({1..n},k)" will compute all k element subsets of {1,...,n} for us, 
-----             IN THE SAME ORDERING as the Plucker vector from "exteriorPower" above -----
     
     
     
notLessThan = method(TypicalValue=>Boolean)
notLessThan(List,List) := (beta,alpha) -> (
      NotLessThan = false;
      for i from 1 to length(beta) do
      if beta_(i-1) > alpha_(i-1) then NotLessThan = true;
      return(NotLessThan))
      
allNotLessThan = method()
allNotLessThan(List,ZZ) := (alpha, n) -> (
      L = {};
      for beta in subsets(splice {1..n},length(alpha)) do
      if notLessThan(beta,alpha) then L = append(L,beta);
      return(L))
      
----- NOTE: Need to adjust so that field isn't always QQ for cauchyBinet below
cauchyBinet = method()
cauchyBinet(ZZ,ZZ,Matrix,List) := (k,n,F,L) -> (
      Finv = inverse F;
      M = mutableMatrix(QQ,length(L),binomial(n,k));
      subs = subsets(splice {1..n},k);
      kOnes = splice{k:1};
      for i from 0 to length(L)-1 do
      for j from 0 to binomial(n,k)-1 do
      M_(i,j) = det(submatrix(Finv,L_(i)-kOnes,subs_(j)-kOnes));
      return(matrix M))
      
schubertIdeal = method()
----- NOTE: There should be m alphas and m-1 flags (first flag will be assumed to be the identity and not given as input)
----- NOTE: The flags should be general and the alpha's codimensions should add up to k(n-k) to give an actual Schubert problem
schubertIdeal(ZZ,ZZ,List,List) := (k,n,alphas,flags) -> (
      coords = typeAStiefelCoords(k,n,alphas_(0),QQ);
      R = coords_(1);
      I = ideal(0_R);
      PY = exteriorPower(k,coords_(0));
      for i from 1 to length(alphas)-1 do 
      I = I + ideal(cauchyBinet(k,n,flags_(i-1),allNotLessThan(alphas_(i),n))*PY);
      return(I))
