//test.lib
//
//  This is for procedures that are being tested and developed before 
//  committing to the main library file
//
//  Warning:  The full documentation mode for a procedure generates an error message
//              if the procedure is in an ordinary input file, but not if it is in a .lib file.
//            This is strange, but consistent with what I saw in my last 1/2 hour of frustration
//
//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are partial permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////
//
// proc lengthOfPermutation ( intvec w )
//       Computes the Coxeter group length of the partial permutation w 
//
//     ---> This is not yet used
//
// proc isCondition (intvec w, intvec flagType)   returns a boolean 0 or 1
//      Checks if partial permutation w is a Schubert condition for manifold of type flagType
//
//     ---> This is not yet used
// proc smallerPermutations ( intvec w )
//      Generates a list of all permutations less than or equal to the given permutation
//
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/* Computes the Coxeter group length of the partial permutation w              /*
proc lengthOfPermutation ( intvec w )
{
  int n = sort(w)[1][nrows(w)];
  int i,j;
  w = completePermutation( w, n );
  int len = 0;
  for ( i=1; i<n; i++) {
    for ( j=i+1; j<=n; j++) {
      if ( w[i]>w[j] ) { len++; }
    }
  }
  return ( len );
}
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/*  Checks if partial permutation w is a Schubert condition for the
       flag manifold of type flagType                                         */
//
proc isCondition (intvec w, intvec flagType)
"USAGE:  isCondition( w, flagType);  w intvec, flagType intvec
   
 RETURN: int: 1 if the partial permutation w has descents in the set flagType
              0 if not, including if it is not a partial permutation.
	This is the requirement that w is a Schubert condition for the flag variety
              encoded by flagType
   
 Example: example isCondition; shows an example"
{
  int fits = isPartialPermutation( w );
  if (member(nrows(w), flagType)==1) {
    for (int i=1; i<nrows(w); i++) {
      if (w[i]>w[i+1]) { fits = fits * member(i,flagType); }
    }
  }
  return( fits );
} 
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  intvec flagType = 2, 3, 5;   
  isCondition(w, flagType);   
} 






/////////////////////////////////////////////////////////////////////////////////
/*      Generates a list of all permutations less than 
                 or equal to the given permutation        
             do we want to somehow order them? maybe lex?             
 To do:
    (1) Add example
    (2) Add documentation 
    (3) Add error catching code */

proc smallerPermutations ( intvec w )
{
  int i, j, k, ii;
  int newPerm;
  list permList=w;

  for (i=1; i<=size(permList); i++){
    for (j=1; j<=size(permList[i])-1; j++){
      for (k=j+1; k<=size(permList[i]); k++){
        if (permList[i][j] > permList[i][k]){
          newPerm=1;
          w=permList[i];
          w[j]=permList[i][k];
          w[k]=permList[i][j];
          for (ii=1; ii<=size(permList); ii++){
            if (permList[ii] == w){
              newPerm=0;
            }
          }
          if (newPerm){
            permList[size(permList)+1]=w;
          }
        }
      }
    }
  }
}
/////////////////////////////////////////////////////////////////////////////////
