//test.lib
//
//  This is for procedures that are being tested and developed before 
//  committing to the main library file
//
//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are partial permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////
//
// proc isCondition (intvec w, intvec flagType)   returns a boolean 0 or 1
//      Checks if partial permutation w is a Schubert condition for manifold of type flagType
//
// proc completePermutation ( intvec w, int n ) returns an intvec (a permutation)
//      Completes a partial permutation w to a full permutation for flagType or breaks
//
// proc partitionToPermutation ( intvec partition, int k, int n )
//       Converts a partition for Gr(k,n) into the corresponding permuation or breaks
//
// proc getDescents (intvec w)
//       Gets the descent set of a partial permutation w.  The first descent is at 0 
//
// proc makeGrassmannianPermutation ( intvec w, int k, int n)
//       Computes the Grassmannian permutation of a partial permutation w given by 
//       the first k values of w.  This indexes the Schubert variety of the image  
//
// proc lengthOfPermutation ( intvec w )
//   Computes the Coxeter group length of the partial permutation w 
//
///////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
/*  Checks if partial permutation w is a Schubert condition for the
       flag manifold of type flagType                                         */
//
proc isCondition (intvec w, intvec flagType)
"USAGE:  isCondition( w, flagType);  w intvec, flagType intvec
   
 RETURN: int: 1 if the partial permutation w has descents in the set flagType
              0 if not, including if it is not a partial permutation.
	This is the requirement that w is a Schubert condition for the flag variety
              encoded by flagType
   
 Example: example isCondition; shows an example"
{
  int fits = isPartialPermutation( w );
  if (member(nrows(w), flagType)==1) {
    for (int i=1; i<nrows(w); i++) {
      if (w[i]>w[i+1]) { fits = fits * member(i,flagType); }
    }
  }
  return( fits );
} 
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  intvec flagType = 2, 3, 5;   
  isCondition(w, flagType);   
} 
/////////////////////////////////////////////////////////////////////////////////
/*  Completes a partial permutation w to a full permutation for S_n            */
//
proc completePermutation ( intvec w, int n )
"USAGE:  completePermutation( w, n);  w intvec, n int
   
 RETURN: The full permutation in S_n whose initial values agree with w, and remaining
           values are increasing.

 Example: example completePermutation; shows an example"
{
  if (isPartialPermutation(w) <>1 ) {
    printf("Input failure for completePermutation ( intvec (%s), int %s ) :",w, n);
    printf("The vector (%s) is not a partial permutation.",w);
    quit;
  }
  if ( nrows(w) < n ) {
    for ( int i=1; i<=n; i++ ) {
      if (member(i,w)==0) { w = w, intvec(i); }
    }
  }
  return ( w );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  int n = 5;   
  completePermutation(w, n);   
}
//   The result should be 1,4,3,2,5
/////////////////////////////////////////////////////////////////////////////////
/* Converts a partition Gr(k,n) into the corresponding permuation.             */
//
proc partitionToPermutation ( intvec partition, int k, int n )

"USAGE:  partitionToPermutation( partition, k, n);  partition intvec, k int, n int
   
 RETURN: The full permutation in S_n with unique descent at k corresponding to the
           given partition.  w[i] = i + partition[k+1-i] -1 for i=1..k

 NOTE: This checks that k < n and that the partition has at most k parts.
        It does not yet check that the partition is weakly decreasing with
	largest part at most n-k.
   
 Example: example partitionToPermutation; shows an example"
{
  if (n<=k) {
    printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
    printf("The dimension %s of the ambient space is larger than the dimension %s of a subspace.",n,k);
    quit;
  }
  if (k<nrows(partition)) {
    printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
    printf("The partition (%s) has more parts than %s, so it is not a condition on Gr(%s,%s).",partition,k,k,n);
    quit;
  } 
  for (int i=nrows(partition)+1; i<=k; i++) {
    partition = partition , intvec(0);
  }
  intvec condition= 1+partition[k];
  for (i=2; i<=k; i++) {
    condition = condition , intvec(i+partition[k+1-i]);
  }
   completePermutation ( condition, n ) ;
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec lam = 2,2,1;   
  int k = 4;   
  int n = 8;   
  partitionToPermutation( lam, k, n);
}
//   The result should be 1,3,5,6, 2,4,7,8
/////////////////////////////////////////////////////////////////////////////////
/* Computes the Grassmannian permutation of a partial permutation w given by   */
/*  the first k values of w.  This indexes the Schubert variety of the image   */
//
proc makeGrassmannianPermutation ( intvec w, int k, int n)

"USAGE:  makeGrassmannianPermutation( w, k, n);  w intvec, k int, n int
   
 RETURN: The full permutation in S_n with unique descent at k whose first k values
           are the first k values of the completion of w to a permutation in S_n,
	   sorted in order.

 NOTE: This does not check that w is a partial permutation.
   
 Example: example makeGrassmannianPermutation; shows an example"
{
  if (size(w)<n) { w = completePermutation ( w, n ); }
  intvec tmp = w[1];
  for (int i=2; i<=k; i++) {
    tmp = tmp, intvec(w[i]);
  }
  completePermutation ( sort(tmp)[1], n );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 3,5, 1,6, 2,7;   
  int k = 4;   
  int n = 8;   
  makeGrassmannianPermutation( w, k, n);
}
//   The result should be 1,3,5,6, 2,4,7,8
/////////////////////////////////////////////////////////////////////////////////
/* Gets the descent set of a partial permutation w.  The first descent is at 0 */
//
proc  getDescents (intvec w)

"USAGE:  getDescents( w );  w intvec
   
 RETURN: The integer vector whose components are the descent set { i : w[i]>w[i+1] }
           of w.

 NOTE: This does not check that w is a partial permutation.
   
 Example: example getDescents; shows an example"
{
  intvec descents;
  for (int i=1; i<=nrows(w)-1; i++) {
    if (w[i]>w[i+1]) { descents = descents , intvec(i) ; }
  } 
  descents = descents , nrows(w);
  return ( descents );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 3,5, 1,6, 2,7;   
  getDescents( w );
}
//   The result should be 2, 4, 6
/////////////////////////////////////////////////////////////////////////////////
/* Computes the Coxeter group length of the partial permutation w              /*
proc lengthOfPermutation ( intvec w )
{
  int n = sort(w)[1][nrows(w)];
  int i,j;
  w = completePermutation( w, n );
  int len = 0;
  for ( i=1; i<n; i++) {
    for ( j=i+1; j<=n; j++) {
      if ( w[i]>w[j] ) { len++; }
    }
  }
  return ( len );
}
/////////////////////////////////////////////////////////////////////////////////
