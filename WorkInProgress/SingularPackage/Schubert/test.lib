//test.lib
//
//  This is for procedures that are being tested and developed before 
//  committing to the main library file
//
//  Warning:  The full documentation mode for a procedure generates an error message
//              if the procedure is in an ordinary input file, but not if it is in a .lib file.
//            This is strange, but consistent with what I saw in my last 1/2 hour of frustration
//
//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are partial permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////
//
// proc lengthOfPermutation ( intvec w )
//       Computes the Coxeter group length of the partial permutation w 
//
//     ---> This is not yet used
//
// proc isCondition (intvec w, intvec flagType)   returns a boolean 0 or 1
//      Checks if partial permutation w is a Schubert condition for manifold of type flagType
//
//     ---> This is not yet used
// proc smallerPermutations ( intvec w )
//      Generates a list of all permutations less than or equal to the given permutation
//
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/* Computes the Coxeter group length of the partial permutation w              /*
proc lengthOfPermutation ( intvec w )
{
  int n = sort(w)[1][nrows(w)];
  int i,j;
  w = completePermutation( w, n );
  int len = 0;
  for ( i=1; i<n; i++) {
    for ( j=i+1; j<=n; j++) {
      if ( w[i]>w[j] ) { len++; }
    }
  }
  return ( len );
}
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/*  Checks if partial permutation w is a Schubert condition for the
       flag manifold of type flagType                                         */
//
proc isCondition (intvec w, intvec flagType)
"USAGE:  isCondition( w, flagType);  w intvec, flagType intvec
   
 RETURN: int: 1 if the partial permutation w has descents in the set flagType
              0 if not, including if it is not a partial permutation.
	This is the requirement that w is a Schubert condition for the flag variety
              encoded by flagType
   
 Example: example isCondition; shows an example"
{
  int fits = isPartialPermutation( w );
  if (member(nrows(w), flagType)==1) {
    for (int i=1; i<nrows(w); i++) {
      if (w[i]>w[i+1]) { fits = fits * member(i,flagType); }
    }
  }
  return( fits );
} 
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  intvec flagType = 2, 3, 5;   
  isCondition(w, flagType);   
} 




/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/*  Gets the set of locations where a permutation w increases by at least two
      ignores increases after last descent                                    

      To do: 1) Add help documentation
             2) Add example
             3) Maybe error catching code, though this is likely static

Frank asks:  What is this code for ?

*/

proc criticalConditions (intvec w)
{
  int i, descent;
  intvec jumps, allDescents;
  allDescents = getDescents(w);
  if ( size(allDescents) > 1){
    descent = allDescents[size(allDescents)-1];
  }
  else{
    descent = allDescents[1];
  }
  if (w[1] > 1){
    jumps[1]=1;
  }
  if (descent > 1){
    for (i=2; i <= descent; i++){
      if (w[i] > w[i-1]+1){
        jumps[size(jumps)+1]=i;
      }
    }
    if (jumps[1] == 0){
      jumps= jumps[2..size(jumps)];
    }
  }
  return(jumps);
}

/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/*  Returns a list of all permutations that are not greater than
     or equal to the given permutation in the Bruhat order                           

      To do: 1) Add help documentation  <--- This should have been done while coding this procedure.
             2) Add example
             3) Error catching code including check it has unique descent
             4) Come up with better function name                           

Frank's comments:   This is an internal procedure and is only called with input
    a permutation with a single descent.

  */

proc ngeqPermutations (intvec w, list #)
{
  // Insert check for unique descent
  if (size(#) <> 1){
    #[1]=size(w);
//
//   Did you test this?  I do not think that it is good programming to modify parameters,
//     and maybe that is not allowed.
//
  }
  if (size(w) <> #[1]){
    w = completePermutation (w, #[1]);
//
//   See comment above on modifying parameters.
//
  }
  if (w == (1..#[1]) ){
    printf("Given permutation is the identity permutation");
//
//   This is not an error !!!!!!!
//
    quit;
  }
  int i,j,tooBig;
  int descent = getDescents[1];
  intvec jumps;
  intvec v = 1..descent;
  list permutations;
  while (v[1] <= #[1]-descent){
    tooBig = 1;
    for (i=1; i <= size(jumps); i++){
      if ( v[jumps[i]] < w[jumps[i]] ){
        tooBig = 0;
        break;
      }
    }
//
// What is this code doing?  It needs an internal comment.  This is a global question
//   about this procedure.
//
    if (tooBig or (v[descent] > #[1]) ){
      if (tooBig){
        i = jumps[1]-1;
      }
      else{
        i = descent-1;
      }
      if (not i){
        break;
      }
      for (i=i; i > 0; i = i-1){
        if (v[i] < #[1]+descent-i){
          v[i] = v[i]+1;
          for (i= i+1; i <= descent; i++){
            v[i] = v[i-1]+1;
          }
          break;
        }
      }
    }
    else{
      permutations[size(permutations)+1] = completePermutation(v,#1);
      v[descent] = v[descent]+1;
    } 
  }
  return(permutations);
}
