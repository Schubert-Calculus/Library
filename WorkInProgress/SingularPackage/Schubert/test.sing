//  This is for testing the new schubert.lib
//
// Note schubert.lib calls linalg.lib and matrix.lib
//
//   NOTE: Singular is 1-based: intvec v = 1,2,3;  v[1]=1.
//
//  Warning:  The full documentation mode for a procedure generates an error message
//              if the procedure is in an ordinary input file, but not if it is in a .lib file.
//            This is strange, but consistent with what I saw in my last 1/2 hour of frustration
//
//
//  Provides procedures to make Stiefel coordinates
//
//  
//
option(redSB); 
LIB "schubert.lib"; 
LIB "test.lib"; 

//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////



intvec myFlagType =  2, 5, 8;
intvec w = 2,6, 3,4,7, 1,5,6;
list conditions = w ;

myFlagType =  4,10;
w = completePermutation( intvec(1,4,5,7), myFlagType[nrows(myFlagType)]);
intvec v = completePermutation( intvec(1,3,4,8), myFlagType[nrows(myFlagType)]);
 conditions = w,v ;


list myRingData = "0", "y", "dp";
def myRing = makeStiefelCoordinateRing(  myFlagType, conditions , myRingData)[1];
setring myRing;
basering;

print(makeStiefelCoordinates ( myFlagType, conditions, myRingData));

quit;


