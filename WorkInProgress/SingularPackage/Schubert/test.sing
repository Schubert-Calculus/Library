//  This is for testing the new schubert.lib
//
// Note schubert.lib calls linalg.lib and matrix.lib
//
//   NOTE: Singular is 1-based: intvec v = 1,2,3;  v[1]=1.
//
option(redSB); 
LIB "schubert.lib"; 
LIB "test.lib"; 

//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////
//
// proc member (int d, intvec a)   returns a boolean 0 or 1
//        Checks if integer d is a component of vector a
//
// proc isCondition (intvec w, intvec flagType)   returns a boolean 0 or 1
//      Checks if partial permutation w is a Schubert condition for manifold of type flagType
//
// proc completePermutation ( intvec w, intvec flagType ) returns an intvec (a permutation)
//      Completes a partial permutation w to a full permutation for flagType or breaks
//
// proc partitionToPermutation ( intvec partition, int k, int n )
//       Converts a partition for Gr(k,n) into the corresponding permuation or breaks
//
// proc getDescents (intvec w)
//       Gets the descent set of a partial permutation w.  The first descent is at 0 
//
// proc makeGrassmannianPermutation ( intvec w, int k, int n)
//       Computes the Grassmannian permutation of a partial permutation w given by 
//       the first k values of w.  This indexes the Schubert variety of the image  
//
//////////////////////////////////////////////////////////////////////////////////////
//
// ToDo:  lengthOfPermutation


intvec myFlagType =  2, 5, 8;
intvec w = 2,8, 3,4,7, 1,5,6;
intvec v = 2,4, 5,7,8;
intvec x = 2,8;

//w=1,4, 2,5,7;

// myFlagType =  2, 5, 8, 12;
// w = 1,8, 3,7,11, 2,6,9;
w = completePermutation( w, myFlagType[nrows(myFlagType)]);

intvec flagType = myFlagType;

  int i,j,ii;
  int n = flagType[nrows(flagType)];
  int m = flagType[nrows(flagType)-1];
  intvec extendedFlagType = intvec(0), flagType;
  intmat patternMatrix[n][m];
  //
  for (i=1; i<=n; i++) {
    for (j=1; j<=m; j++) {
      patternMatrix[i,j] = 2;
    }
  }
  for  (j=1; j<=m; j++) {
    patternMatrix[n+1-w[j],j] = 1;
    for (i=n+2-w[j]; i<=n; i++) {
      patternMatrix[i,j] = 0;
    }
    for (i=j+1; i<=m; i++) {
      patternMatrix[n+1-w[j],i] = 0;
    }
  }
  //
  for (ii=1; ii<nrows(extendedFlagType)-1; ii++) {
    for (j=extendedFlagType[ii]+1; j<=extendedFlagType[ii+1]; j++) {
      for (i=extendedFlagType[ii]+1; i<j; i++) {
        patternMatrix[n+1-w[j],i] = 0;
      }
    }
  }

  list  varIndices;
  for (i=n; i>=1; i--) {
    for (j=m; j>=1; j--) {
      if (patternMatrix[i,j] == 2) {
        varIndices = insert( varIndices, intvec(i,j) );
      }
    }
  }

print(patternMatrix);

list #;

#[1] = "0"; #[2] = "x"; #[3] = "dp";

  int i = 1;   
  string ringconstructor = "ring nameofmyprettyring = " + #[1] + ",(" ;
  ringconstructor =  ringconstructor + #[2] + "(" + string(varIndices[1]) + ")";
  for (i=2; i<=size(varIndices); i++)   
    {   
      ringconstructor = ringconstructor + ",";   
      ringconstructor = ringconstructor + #[2] + "(" + string(varIndices[i]) + ")";   
    }   
  ringconstructor = ringconstructor + ")," + #[3] + ";";   

ringconstructor;

ring R = 0, (x(2,1),x(3,2),x(5,6)), dp;

quit;
