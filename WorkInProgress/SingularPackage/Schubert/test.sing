//  This is for testing the new schubert.lib
//
// Note schubert.lib calls linalg.lib and matrix.lib
//
//   NOTE: Singular is 1-based: intvec v = 1,2,3;  v[1]=1.
//
//  Warning:  The full documentation mode for a procedure generates an error message
//              if the procedure is in an ordinary input file, but not if it is in a .lib file.
//            This is strange, but consistent with what I saw in my last 1/2 hour of frustration
//
//
option(redSB); 
LIB "schubert.lib"; 
LIB "test.lib"; 

//////////////////////////////////////////////////////////////////////////////////////
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
//////////////////////////////////////////////////////////////////////////////////////
//
// Schubert conditions are permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
//
//  Make a ring with indexed variables and exports it.
//
//  # is a list  "nameOfRing", "characteristic", "variable name", "monomial order"
//
//   Note, only the generic monomial orderings dp; etc. make sense here as
//          we do not know the number and order of variables without looking closer.
//
proc myIndexedRing (list indicesOfVariables, list #)   
{   
  if (size(#)==0 or size(#)>4) { #[1] = "R"; #[2] = "0"; #[3] = "x"; #[4] = "dp";}   
  if (size(#)==1) { #[2] = "0"; #[3] = "x"; #[4] = "dp";}   
  if (size(#)==2) { #[3] = "x"; #[4] = "dp";}   
  if (size(#)==3) { #[4] = "dp";}   

  intvec pr;
  int i;
  string ringConstructor = "ring " + #[1] + " = " + #[2] + ",(" ;
  for ( i=1; i<=size(indicesOfVariables); i++ )  {
    pr = indicesOfVariables[i];
    if ( i>1 ) { ringConstructor = ringConstructor + ","; }
    ringConstructor =  ringConstructor + #[3] + "(" + string(pr[1]) + ")" + "(" + string(pr[2]) + ")";
  }   
  ringConstructor = ringConstructor + ")," + #[4] + ";";   
  execute(ringConstructor);   
  execute("export " + #[1] + ";");
}
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
//
// Makes Stiefel coordinates for the Schubert variety X_w I, where w is a
//   Schubert condition for the flag variety  flagType and I is the standard
//   coordinate flag.  This is if there is one permutation w in conditions.
// When conditions has two permutations (and necessarily the flag variety
//   a Grassmannian), then it makes Stiefel coordinates for X_w I \cap X_v I',
//   where I' is the opposite flag.
// # specifies the ring.  It is a list of four strings, the ring name, the characteristic, 
//   general ring variable name, and term order.
//
proc makeStiefelCoordinates ( intvec flagType, list conditions, list # )
{
  if (size(#)==0 or size(#)>4) { #[1] = "R"; #[2] = "0"; #[3] = "x"; #[4] = "dp";}   
  if (size(#)==1) { #[2] = "0"; #[3] = "x"; #[4] = "dp";}   
  if (size(#)==2) { #[3] = "x"; #[4] = "dp";}   
  if (size(#)==3) { #[4] = "dp";}   

  int i,j,ii;
  int n = flagType[nrows(flagType)];
  int m = flagType[nrows(flagType)-1];
  intvec extendedFlagType = intvec(0), flagType;
  intmat patternMatrix[n][m];
  //
  //  First, make a square integer matrix of 2s  (2 is a place keeper)
  //
  for (i=1; i<=n; i++) {
    for (j=1; j<=m; j++) {
      patternMatrix[i,j] = 2;
    }
  }
  //
  //  Next, place w in the pivots
  //
  for  (j=1; j<=m; j++) {
    patternMatrix[n+1-w[j],j] = 1;
    for (i=n+2-w[j]; i<=n; i++) {
      patternMatrix[i,j] = 0;
    }
    for (i=j+1; i<=m; i++) {
      patternMatrix[n+1-w[j],i] = 0;
    }
  }
  //
  //  Finishes the Stiefel coordinates for X_w I
  //
  if (size(conditions) == 1) {
    for (ii=1; ii<nrows(extendedFlagType)-1; ii++) {
      for (j=extendedFlagType[ii]+1; j<=extendedFlagType[ii+1]; j++) {
        for (i=extendedFlagType[ii]+1; i<j; i++) {
          patternMatrix[n+1-w[j],i] = 0;
        }
      }
    }
  }
   else
  //
  //  In this case, we must have that flagType = (k,n) so that we are on a Grassmannian
  //
  {
    if (nrows(flagType) > 2) {
      printf("Input failure for makeSteifelCoordinates ( intvec (%s), intvec (%s), intvec (%s) ) :",
               flagType, conditions[1], conditions[2]);
      printf("The flag variety is not a Grassmannian, as flagType = (%s), and the Richarson variety",flagType);
      printf("option requires a Grassmannian.");
      quit;
    }
    intvec v = conditions[2];
    //
    //  This returns the pattern for a skew Schubert (Richardson) variety. Must check that it is nonempty,
    //
    for (j=1; j<=m; j++) {
      if ( n+1 < w[j] +v[m+1-j] ) {
      printf("Input failure for makeSteifelCoordinates ( intvec (%s), intvec (%s), intvec (%s) ) :",
               flagType, conditions[1], conditions[2]);
      printf("The conditions (%s) and (%s) define an empty Richardson variety",w,v);
      quit;
      }
      for (i=1; i<v[m+1-j]; i++) {
        patternMatrix[i,j] = 0;
      }
    }
  }
  //
  //  Find the indices of our variables.
  //
  list  indicesOfVariables;
  for (i=n; i>=1; i--) {
    for (j=m; j>=1; j--) {
      if (patternMatrix[i,j] == 2) {
        indicesOfVariables = insert( indicesOfVariables, intvec(i,j) );
      }
    }
  }
  //
  //  Now we make our ring and plug in indeterminates in to the Stiefel Coordinates
  //
  myIndexedRing( indicesOfVariables, #);
  matrix StiefelCoordinates = matrix(patternMatrix);
  intvec pr;
  for (i=1; i<= size(indicesOfVariables); i++) {
    pr =indicesOfVariables[i];
    StiefelCoordinates[pr[1],pr[2]] = var(i);
  }
  export StiefelCoordinates ;
//  return( StiefelCoordinates );
}


intvec myFlagType =  2, 5, 8;
intvec w = 2,6, 3,4,7, 1,5,6;
intvec v = 2,4, 5,7,8;
intvec x = 2,8;

//w=1,4, 2,5,7;

// myFlagType =  4,10;
// w = completePermutation( intvec(1,4,5,7), myFlagType[nrows(myFlagType)]);
// v = completePermutation( intvec(1,3,4,8), myFlagType[nrows(myFlagType)]);

intvec flagType = myFlagType;
list # = "myRing", "0", "x", "dp";
list conditions = w ;

makeStiefelCoordinates ( myFlagType, conditions,  # );

print(StiefelCoordinates);

def S = basering;

S;

quit;
