//schubert.lib 
// 
//  schubert.lib is a Singular library for formulating Schubert problems and  
//                Schubert conditions on Grassmannians and type A flag manifolds 
//                It builds on an earlier version written by Luis David Garcia-Puente, 
//                James Ruffo, and Frank Sottile 
//
//  This version is being written by Taylor Brysiewicz, Frank Sottile, and Robert Williams
//
//   It appears that `StiefelCoordinates' may be a reserved name.  Need to think about this.
//
//
///////////////////////////////////////////////////////////////////////////////   
version="version SchubertCalculus.lib  1.0.0.0  November_2016 ";   
category="Algebraic geometry"; 
info="   
LIBRARY:  SchubertCalculus.lib  Procedures for formulating Schubert varieties on flag manifolds
AUTHOR:   Taylor Brysiewicz
          Frank Sottile      sottile@math.tamu.edu
	  Robert Williams

OVERVIEW: This library provides procedures for formulating membership in Schubert varieties
           and Schubert problems on classical flag varieties.

REFERENCES: Fulton, Young Tableaux: With Applications to Representation Theory and Geometry, LMSST 35, Cambridge
               University Press

KEYWORDS: Grassmannian; Schubert variety; Schubert Problem; Littlewood-Richardson Rule;

SEE ALSO:

PROCEDURES:
 <proc_name_1>();     <one line description of the purpose>
     .
     .
 <proc_name_N>();     <one line description of the purpose>
";
/////////////////////////////////////////////////////////////////////////////////
LIB "matrix.lib"; 
LIB "linalg.lib"; 
//////////////////////////////////////////////////////////////////////////////////////
//
//   The following two conventions are for type A flag varieties
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n) with increasing 
//           entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
////////
//
// Schubert conditions are partial permutations w of {1,...,n} represented as integer vectors.
//         w has descents only at positions of adot, where flagType=(adot,n)
//
//////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
//
//
//

/////////////////////////////////////////////////////////////////////////////////   
//
//  Static procedures  (This should eventually go in the header ?)
//
//   For testing do not call them static
//
// proc member (int d, intvec a)   returns a boolean 0 or 1
//        Checks if integer d is a component of vector a
//
// proc getDescents (intvec w)
//        Gets the descent set of a sequence w.  The first descent is at 0 and last at nrows(w)
//
// proc isPartialPermutation( intvec w )
//        tests if w is a partial permutation.  1 = yes and 0 = no
//
// proc completePermutation ( intvec w, int n ) returns an intvec (a permutation)
//      Completes a partial permutation w to a full permutation in S_n or breaks
//
// proc partitionToPermutation ( intvec partition, int k, int n )
//       Converts a partition for Gr(k,n) into the corresponding permuation or breaks
//
/////////////////////////////////////////////////////////////////////////////////
/*  Checks if integer d is a component of vector a, returning a boolean 1/0    */
//
//   This is static and not exported
//
proc member (int d, intvec a)
"USAGE:  member(d, a);  d int, a intvec

 RETURN: int: 1 if d is a component of a  and  0 if it is not
 
 Example: example member; shows an example"
 {
  for (int i=1; i<=nrows(a); i++) {
    if (d==a[i]) { return(1) }
  }
  return(0);
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec myFlagType = 2,3,5;   
  int d = 3;   
  member(d, myFlagType);   
} 
/////////////////////////////////////////////////////////////////////////////////
/* Gets the descent set of a partial permutation w.  The first descent is at 0 */
//
proc getDescents (intvec w)

"USAGE:  getDescents( w );  w intvec
   
 RETURN: The integer vector whose components are the descent set { i : w[i]>w[i+1] }
           of w.

 NOTE: This does not check that w is a partial permutation.
   
 Example: example getDescents; shows an example"
{
  intvec descents;
  for (int i=1; i<=nrows(w)-1; i++) {
    if (w[i]>w[i+1]) { descents = descents , intvec(i) ; }
  } 
  descents = descents , nrows(w);
  return ( descents );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 3,5, 1,6, 2,7;   
  getDescents( w );
}
//   The result should be 2, 4, 6
//////////////////////////////////////////////////////////////////////////////////
//
//   This tests if w is a partial permutation.  1 = yes and 0 = no
//
proc isPartialPermutation( intvec w )
"USAGE:  isPartialPermutation( w );  w intvec
   
 RETURN: int: 1 if the integer vector is a partial premutation in that it has positive
                 integral components that are distinct.
              0 if it is not a partial permutation.
   
 Example: example isPartialPermutation; shows an example"
{
  intvec u = sort(w)[1];
  if (u[1] < 1) { return( 0 ); }
  for (int i=1; i<nrows(u); i=i+1) {
   if (u[i] == u[i+1]) { return( 0 ); } 
  }
  return( 1 );
}
example
{
  "EXAMPLE:"; echo = 2;   
  intvec w = 1, 4, 3, 7;   
  isPartialPermutation( w );
  isPartialPermutation( intvec( 1, 4, 3, 4 ) );
  isPartialPermutation( intvec( 1,-1, 3, 4 ) );
}
// should get the values 1, 0, 0 from these inputs
/////////////////////////////////////////////////////////////////////////////////
/*  Completes a partial permutation w to a full permutation for S_n            */
//
proc completePermutation ( intvec w, int n )
"USAGE:  completePermutation( w, n);  w intvec, n int
   
 RETURN: The full permutation in S_n whose initial values agree with w, and remaining
           values are increasing.

 Example: example completePermutation; shows an example"
{
  if (isPartialPermutation(w) <>1 ) {
    printf("Input failure for completePermutation ( intvec (%s), int %s ) :",w, n);
    printf("The vector (%s) is not a partial permutation.",w);
    quit;
  }
  if ( nrows(w) < n ) {
    for ( int i=1; i<=n; i++ ) {
      if (member(i,w)==0) { w = w, intvec(i); }
    }
  }
  return ( w );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  int n = 5;   
  completePermutation(w, n);   
}
//   The result should be 1,4,3,2,5
//////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/* Converts a partition Gr(k,n) into the corresponding permuation.             */
//
proc partitionToPermutation ( intvec partition, int k, int n )

"USAGE:  partitionToPermutation( partition, k, n);  partition intvec, k int, n int
   
 RETURN: The full permutation in S_n with unique descent at k corresponding to the
           given partition.  w[i] = i + partition[k+1-i] -1 for i=1..k

 NOTE: This checks that k < n, that the partition has at most k parts, that it is
        weakly decreasing and if its largest part at most n-k.
   
 Example: example partitionToPermutation; shows an example"
{
  if (n<=k) {
    printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
    printf("The dimension %s of the ambient space is larger than the dimension %s of a subspace.",n,k);
    quit;
  }
  if (k<nrows(partition)) {
    printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
    printf("The partition (%s) has more parts than %s, so it is not a condition on Gr(%s,%s).",partition,k,k,n);
    quit;
  }
  for (int i=1; i<nrows(partition); i++) {
    if (partition[i]<partition[i+1]) {
      printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
      printf("The integer vector (%s) is not a partition, as it is not weakly decreasing.",partition);
      quit;
    }
  }
  if (n-k<partition[1]) {
    printf("Input failure for partitionToPermutation ( intvec (%s), int %s, int %s ) :",partition, k, n);
    printf("The first part of the partition (%s) exceeds %s=%s-%s, so it is not a condition on Gr(%s,%s).",
             partition,n-k,n,k); 
    quit;
  }
  for (i=nrows(partition)+1; i<=k; i++) {
    partition = partition , intvec(0);
  }
  intvec condition= 1+partition[k];
  for (i=2; i<=k; i++) {
    condition = condition , intvec(i+partition[k+1-i]);
  }
   completePermutation ( condition, n ) ;
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec lam = 2,2,1;   
  int k = 4;   
  int n = 8;   
  partitionToPermutation( lam, k, n);
}
//   The result should be 1,3,5,6, 2,4,7,8
/////////////////////////////////////////////////////////////////////////////////
