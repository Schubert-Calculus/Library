//SchubertIdeals.lib 
// 
////////////////////////////////////////////////////////////
// This is a Singular library for computing ideals of
//   Schubert varieties on Grassmannians and flag manifolds 
//   of Lie Types A and C, in systems of local Stiefel
//   coordinates on these spaces.
//
// It builds on an earlier version written by Luis David
//   Garcia-Puente, James Ruffo, and Frank Sottile 
//
// This version is written by  C.J. Bott, Taylor Brysiewicz,
//   and Frank Sottile
//
//  All lines must be at most 60 characters long
////////////////////////////////////////////////////////////
version="version SchubertIdeals.lib 1.0.0.0 April_2024 ";    
category="Algebraic geometry"; 
info="   
LIBRARY:  SchubertIdeals.lib  ideals of Schubert varieties
AUTHOR:   C.J. Bott,          cdott2@tamu.edu
          Taylor Brysiewicz,  tbrysiew@uwo.ca
          Frank Sottile,      sottile@tamu.edu

OVERVIEW: 
This library provides procedures for formulating membership 
in Schubert varieties and Schubert problems on classical 
flag varieties (currently Lie types A and C).  It also may
compute degrees of Schubert problems.

REFERENCES: 
Fulton, Wm., Young Tableaux: With Applications to 
  Representation Theory and Geometry, LMSST 35, CUP 1995.
Fulton, Wm. and Pragacz, P., Schubert Varieties and 
  Degeneracy Loci, LNM 1689, Springer, 1998.

KEYWORDS: Grassmannian; Schubert variety; Schubert Problem; 
    Littlewood-Richardson Rule;

SEE ALSO:

PROCEDURES:
  proc makeStiefelCoordinates ( intvec flagType , list conditions, list # )

 <proc_name_1>();     <one line description of the purpose>
     .
     .
 <proc_name_N>();     <one line description of the purpose>
";


////////////////////////////////////////////////////////////
LIB "matrix.lib"; 
LIB "linalg.lib"; 
LIB "general.lib";
LIB "random.lib";
////////////////////////////////////////////////////////////
//
// Conventions for type A flag varieties:
//
//  flagType is an integer vector (intvec) (a_1, ..., a_s, n)=(adot, n)
//           with increasing entries specifying the type of the flag manifold.
//            flagType = (3,6)  is the Grassmannian of 3-planes in 6-space
//            flagType = (2,3,7) is the manifold of partial flags consisting of a
//                        2-plane contained in a 3-plane lying in 7-space
////////
//
// Schubert conditions are integer vectors w that are partial permutations w of [n]
//         w has descents only at positions of adot, where flagType=(adot,n)
//
// Flags are represented by matrices with n rows
//
///////////////////////////////////////////////////////////////////////
//  Type C   flagType is an intvec (a_1,...,a_s,n) where a_1<...<a_s\leq n
//        This is for isotropic flags of type a_1,...,a_2 in a symplectic 2n vector space
//
//  Schubert conditions are partial permutations w of 1...2n such that w_0 w = w w_0, and may only be specified
//   by their first n values as w(i) + w(2n+1-i) = 2n+1.
//
////////////////////////////////////////////////////////////
//
//   These are the main procedures of this library
//
//
// proc makeStiefelCoordinates ( intvec flagType , list conditions, list # )
//     default for # : ["0", "x", "dp", "stiefelCoordinates"]
//
//     Makes the Stiefel coordinates in the tye A flag variety for either a Schubert variety
//     or a Richardson variety (on a Grassmannian, and with two Schubert conditions
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  proc naiveEquationsGrassmannian ( matrix stiefelCoords, intvec condition, matrix flagMatrix)
//
//   Computes the naive equations in the local stiefelCoords for the Grassmannian Schubert variety
//     given by the condition and flag flagMatrix.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  proc naiveEquationsFlag ( matrix stiefelCoordinates, intvec condition, matrix flag )
//
//   Computes the naive equations in the local stiefelCoords for the Schubert variety
//     given by the condition and flag flagMatrix.
//
//     Lacks checks and documentation
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// proc minimalEquationsGrassmannian( matrix stiefelCoords, intvec condition, matrix flagMatrix)
//  
//   Computes the minimal equations  in the local stiefelCoords for the Grassmannian Schubert variety
//     given by the condition and flag flagMatrix.
//
//     Lacks checks and documentation
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// proc makeLagrangianCoordinates ( intvec w, list # )
//
//
//  makes Stiefel Coordinates for a Schubert subvariety of the Lagrangian Grassmannian, with the standard symplectic form
//
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Procedures for computing flags for Lie type A
//
// proc randomFlag( list(n, range) ) or proc randomFlag( list(n) ) 
//      Generates a random flag, represented as an invertible n x n matrix of numbers
// proc osculatingFlag (int n, poly t)  
//      Generates the flag osculating (s^(n-1)/(n-1)!, ..., s^3/3!, s^2/2, s, 1)^T  at the point s=t
// proc secantFlag (int n, list secantPoints)  
//      Generates the secant flag to the rational normal curve (above) at the pointset secantPoints
//
//
// Procedures for computing flags for Lie type C   &&&&&&&&&&&&&&&&
//
// proc osculatingFlagC ( poly t, int n)
//      Generates the symplectic isotropic flag osculating the rational normal curve
//      transpose( 1, t, t^2/2!, ... , t^(2n-1)/(2n-1)! ) , where positions n+1, n+3, ... are negated.
//  
// proc randomflagC (int n, int range)
//   Generates a random symplectic flag with integer entries; the initial entries are in 
//    -range ..  range
//
//   Need more instructions here.  characteristic, default range, parameters, etc.
//



//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  proc internalJ( int n )
//    Makes the default symplectic form that we use for our coordinates, a 2n x 2n matrix J with J^2 = - I
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  makes Stiefel coordinates in type A for the standard coordinate flag
//   
//  # is a list of strings [characteristic, generic variable name, term order, name_of_coordinates]
//     This is used for the exported ring and the name of the exported coordinates
//     If not set by user, set to default values ["0", "x", "dp", "stiefelCoordinates"]
//
//  Note: cannot use locCoordinats, returns an error message if that is passed
//  This returns a list [ ringDescriptor, list # describing the ring and coordinates ]
//
proc makeStiefelCoordinates ( intvec flagType , list conditions, list # )
"USAGE: makeStiefelCoordinates( flagType, conditions, # ) intvec flagType, list conditions, list #
  Computes local Stiefel coordinates for the given flag manifold (encoded in flagType)  for the Schubert or Richardson
   variety given by the one or two conditions in the list conditions.  # contains information for the ring
   (characteristic, variablename, monomial order, and the name for the matrix of coordinates.

 RETURN: A list containing the ring constructor and exporting of the matrix of coordinates

 EXAMPLE: example makeStiefelCoordinates shows an example"
{
  //   Sets default values for ring constructor, if user did not already set them
  if (size(#)==3) {#[4] = "stiefelCoordinates"; }
  if (size(#)<>4) {#[1] = "0"; #[2] = "x"; #[3] = "dp"; #[4] = "stiefelCoordinates"; }
  if ( #[4] == "locCoordinats" )
  {
    printf("Input failure in makeStiefelCoordinates, must use a different name for local Stiefel Coordinates than locCoordinats");
    quit;
  }
  intvec pr;
  int i,j;
  //   Need the indices of variables
  list indsOfVariables = indicesOfVariables( flagType , conditions );
  //   Make the coordinate ring.  The name R is internal to this proceduire
  string ringConstructor = "ring R = " + #[1] + ",(" ;
  for ( i=1; i<=size(indsOfVariables); i++ )  {
    pr = indsOfVariables[i];
    if ( i>1 ) { ringConstructor = ringConstructor + ","; }
    ringConstructor =  ringConstructor + #[2] + "(" + string(pr[1]) + ")" + "(" + string(pr[2]) + ")";
  }   
  ringConstructor = ringConstructor + ")," + #[3] + ";";
  execute(ringConstructor);

  int n = flagType[nrows(flagType)];
  int m = flagType[nrows(flagType)-1];
  intvec w = conditions[1];
  matrix locCoordinats[n][m];

  for (j=1; j<=flagType[nrows(flagType)-1]; j++) { locCoordinats[n+1-w[j],j] = 1; }
  for ( i=1; i<=size(indsOfVariables); i++ )
  {
    pr = indsOfVariables[i];
    locCoordinats[pr[1],pr[2]] = var(i);
  }
  string coordConstructor = "matrix " + #[4] + " = locCoordinats ;";
  execute(coordConstructor); 
  string exportConstructor = "export( " + #[4] + " );";
  execute(exportConstructor);
  return( list(R, #) );
}
example   
{   
  "EXAMPLE:"; echo = 2;
  intvec myFlagType =  2, 5, 8;
  intvec w = 2,6, 1,4,7;
  list myConditions = w ;
  list myRingData = "0", "y", "dp", "myCoordinates";
  def myRing = makeStiefelCoordinates(  myFlagType, myConditions , myRingData)[1];
  setring myRing;
  print(myCoordinates);
  myFlagType = 3, 7;
  myConditions = intvec(1,3,4), intvec(1,2,5) ;
  def myRing = makeStiefelCoordinates(  myFlagType, myConditions )[1];
  setring myRing;
  print(stiefelCoordinates);
} 
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Computes the naive equations for a Grassmannian condition.
//
//  The condition that a k-plane H in n-space lie in the Schubert variety X_w F is that
//    for each i=1..k, the dimension of H \cap F_{n+1-w[i]} \geq k+1-i , which is equivalent to 
//    for each i=1..k, rank of concat ( H, F[1...(n+1-w[i]) ) \leq n+i-w[i]  (n+i+1-w[i] minors vanish)
//
proc naiveEquationsGrassmannian ( matrix stiefelCoords, intvec condition, matrix flagMatrix)
"USAGE: naiveEquationsGrassmannian( sC, w, F )
  Given a n x k matrix sC of Stiefel coordinates for a subset of the Grassmannian Gr(k,n), computes the ideal 
    of its intersection with the Schubert variety X_w F, via the naive equations (all appropriate minors)

 RETURN: The ideal

 EXAMPLE: example naiveEquationsGrassmannian shows an example"
{
  int n = nrows(stiefelCoords);
  int k = ncols(stiefelCoords);
  if (k <> nrows(condition))
  {
    printf("Input failure for naiveEquationsGrassmannian. The Schubert condition (%s) does not have the same length as the columns of the Stiefel Coordinates.",condition);
    quit;
  }
  if (n <> nrows(flagMatrix) or n <> ncols(flagMatrix) )
  {
    printf("Input failure for naiveEquationsGrassmannian. The Stiefel Coordinates and Flag do not have compatible dimensions");
    quit;
  }
  matrix tempMat;
  ideal I = 0;
  int i;
  // finds the essential conditions
  intvec jmps = jumps(condition);
   intvec flagCols;
  // sets up the matrices and ideald of minors for the essential conditions
  for (i=1; i<=nrows(jmps); i++)
  {
    flagCols =  1..(n+1-condition[jmps[i]]) ;
    tempMat = concat( stiefelCoords, submat(flagMatrix,1..n,flagCols));
    I = I + ideal(minor(tempMat,n+1+jmps[i]-condition[jmps[i]]));
  }
  return(I);
}
example   
{   
  "EXAMPLE:"; echo = 2;
   myFlagType = 3, 6;
   myConditions = intvec(1,3,5), intvec(1,3,5) ;
   def myRing = makeStiefelCoordinates(  myFlagType, myConditions )[1];
   setring myRing;
   matrix myFlag =  randomFlag( list( 6 ) );
   ideal I = naiveEquationsGrassmannian ( stiefelCoordinates, intvec(1,3,5), myFlag);
   I = std(I);
   dim(I), mult(I);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Computes the naive equations for Schubert variety in a manifold of partial flags
//
//    Lacks checks   Needs documentation and example
//
proc naiveEquationsFlag ( matrix stiefelCoordinates, intvec condition, matrix flag )
{
  intvec conditionInGrassmannian;
  matrix coordinatesInGrassmannian;
  ideal I=0;
  intvec descents = getDescents( condition );
  int n = nrows(stiefelCoordinates);

  // This is to handle there being an identity condition
  if ( descents[1]<>0 )
  {
    for (int i=1; i<=nrows(descents); i++)
    {
      conditionInGrassmannian = condition[1..descents[i]];
      conditionInGrassmannian = sort(conditionInGrassmannian)[1];
      coordinatesInGrassmannian = submat( stiefelCoordinates, 1..n, 1..descents[i]);
      I = I +  naiveEquationsGrassmannian( coordinatesInGrassmannian, conditionInGrassmannian, flag);
    }
  }
  return( I );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Generates a random flag, represented as an invertible n x n matrix of numbers
//
proc randomFlag( list # )
"USAGE: matrix M = randomFlag( [n, range] ) or  matrix M = randomFlag( [ n ] )
  Creates a random invertible n x n matrix. 
  In characteristic p > 0, the entries are uniformily chosen random integers between 1 and p.
  In characteristic 0, they are rational numbers a/b where a is a random integer in -range...range and b in 1..range.
      With one entry, range is set to 100.
 RETURN: The random flag
 NOTE: This requires a basering to be active
 EXAMPLE: example randomFlag shows an example"
{
  if (size(#)==0 or size(#)>2) { print("incorrect input for randomFlag");  quit; }

  int n = #[1];
  int i,j, range;
  poly val = 0;
  matrix M[n][n];
  if  (char(basering)<>0)
  {
    range = char(basering) - 1;
    while ( val==0 )
    {
      for (i=1; i<=n; i++)
      {
        for (j=1; j<=n; j++)
        {
          M[i, j]=random(0, range);
        }
      }
      val = det( M );
    }
  }
  else  // characteristic zero
  {
    if (size(#)==1)  // set default for range
    {
      #[2]=100; 
    }
    while ( val==0 )
    {
      range = #[2];
      M = random( range, n, n);
      for (i=1; i<=n; i++)
      {
        for (j=1; j<=n; j++)
        {
          M[i, j]=M[i, j]/random(1, range);
        }
      }
      val = det( M );
    }
  }
  return( M );
}
example   
{   
  "EXAMPLE:"; echo = 2;
  ring R=0,x,dp;
  print(randomFlag( list(4, 1234) ));
  ring S=101,y,lp;
  print(randomFlag( list(4) ));
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates the n x n matrix of the flag osculating the rational normal curve
//  (s^(n-1)/(n-1)!, ..., s^3/3!, s^2/2, s, 1)^T  at the point s=t
//
proc osculatingFlag (int n, poly t)  
"USAGE: matrix M = osculatingFlag( n, t )
  Creates the matrix of format n x n of flags osculating the rational normal curve
      transpose ( ( s^(n-1)/(n-1)!, ..., s^3/3!, s^2/2, s, 1 ) )  at the point s=t.
 RETURN: The osculating flag
 NOTE:    Requires a basering.  When t=0, the osculating flag is the coordinate flag opposite to the standard flag.
           This may cause issues with local coordinates of Richardson varieties
 EXAMPLE: example osculatingFlag shows an example"
{  
  matrix osculatingFlag[n][n];  
  int i,j;  
  for (i=1; i<=n; i++)  
  {  
    osculatingFlag[n+1-i,i] = 1;  
    for (j=i+1; j<=n; j++)  
    {  
      osculatingFlag[n+1-j,i] = t^(j-i)/factorial(j-i);
    }
  }
  return(osculatingFlag);  
}  
example   
{   
  "EXAMPLE:"; echo = 2;
  ring R=0,t,dp;
  print(osculatingFlag( 5, t ));
  print(osculatingFlag( 5, 7 ));
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates the matrix of the flag secant to the rational normal curve (s^(n-1)/(n-1)!, ..., s^3/3!, s^2/2, s, 1)^T
//    at the given list of secant points
//
proc secantFlag (int n, list secantPoints)  
"USAGE: matrix M = secantFlag( n, secantPoints )

  Creates the matrix of format n x n of flags secant to the rational normal curve
      transpose (  (1, s, s^2/2, s^3/3!, ...) )  at the points in secantPoints

 RETURN: The secant flag

 EXAMPLE: example secantFlag shows an example"
{
  if (size(secantPoints) < n)
  {
    printf("Input failure for secantFlag.  Insufficiently many points of secancy.");
    quit;
  }
  matrix secantFlag[n][n];  
  int i,j;
  for (j=1; j<=n; j++)  
    {
      for (i=1; i<=n; i++)  
	{  
	  secantFlag[i,j] = secantPoints[j]^(i-1)/factorial(i-1);  
	}  
    }  
  return( secantFlag );  
}
example
{   
  "EXAMPLE:"; echo = 2;
  ring R=0,t,dp;
  print(secantFlag( 5, list(t,1,2,3,4) ));
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////	
//
//   Computes the minimal equations  in the local stiefelCoords for the Grassmannian Schubert variety
//     given by the condition and flag flagMatrix.
//
//  This assumes (and will check) that everything is in a Grassmannian Gr(k,n).
//
proc minimalEquationsGrassmannian( matrix stiefelCoords, intvec condition, matrix flagMatrix)
{
  int n = nrows(stiefelCoords);
  int k = ncols(stiefelCoords);
  if (k <> nrows(condition))
  {
    print("The Schubert condition is not compatible with the Stiefel Coordinates");
    quit;
  }
  int i,j;
  list flagCoords;
  ideal I;
  poly f;
  list pIndices = plueckerIndices( k, n );
  list pluckerCoordinates = plueckerVector( pIndices, stiefelCoords);
  matrix flagInverse = inverse(flagMatrix);
 
  list conds = allNotLessThan( condition, n, pIndices);
  I = 0;
  for (i=1; i<=size(conds); i++)
  {
    flagCoords =  plueckerVector(pIndices, transpose(submat(flagInverse, conds[i], 1..n)));
    f=0;
    for (j=1; j<=size(pluckerCoordinates); j++)
    {
      f = f + pluckerCoordinates[j]*flagCoords[j];
    }
    I = I + ideal(f);
  }
  return(I)
}
example
{
  "EXAMPLE:"; echo = 2;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  makes Stiefel Coordinates for a Schubert subvariety of the Lagrangian Grassmannian, with the standard symplectic form
//
//   
//  # is a list of strings [characteristic, generic variable name, term order, name_of_coordinates]
//     This is used for the exported ring and the name of the exported coordinates
//     If not set by user, set to default values ["0", "x", "dp", "stiefelCoordinates"]
//
//  Note: cannot use locCoordinats, returns an error message if that is passed
//  This returns a list [ ringDescriptor, list # describing the ring and coordinates ]
//
proc makeLagrangianCoordinates ( intvec w, list # )
//
//   May be able to upgrade to a pair of conditions.
//
"USAGE: makeLagrangianCoordinates( w , # ) intvec w, list #
  Computes local Stiefel coordinates for Schubert variety given by w in the Lagrangian Grassmannian.
   # contains information for the ring (characteristic, variablename, monomial order), and the name for the matrix of coordinates.

 RETURN: A list containing the ring constructor and exporting of the matrix of coordinates

 EXAMPLE: example makeLagrangianCoordinates shows an example"
{
  if (isLagrangianCondition( w ) != 1)
  {
    print("The input to makeLagrangianCoordinates is not the index of a Lagrangian Schubert variety");
    quit;
  }
  //   Sets default values for ring constructor, if user did not already set them
  if (size(#)==3) {#[4] = "stiefelCoordinates"; }
  if (size(#)<>4) {#[1] = "0"; #[2] = "x"; #[3] = "dp"; #[4] = "stiefelCoordinates"; }
  if ( #[4] == "locCoordinats" )
  {
    printf("Input failure in makeLagrangianCoordinates, must use a different name for local Stiefel Coordinates than locCoordinats");
    quit;
  }
  int n = nrows(w);
  int i,j;
  intvec pr;
  //
  //  Need wo and wc to get indices of variables
  //
  intvec wo = intvec(0), w;
  intvec wc;
  for (i=1; i<=n; i++)
  {
    wc[i] = 2*n+1-w[i];
  }
  list indsOfVariables = list();
  //  Finds the indices of variables in Stiefel coordinates for the Lagrangian Grassmannian, when there is one Schubert condition
  for (i=1; i<=n; i++)
  {
     for (j=1; j<=n; j++)
     {
       if (wo[j] < w[i] and w[i] < wc[j]) { indsOfVariables = insert( indsOfVariables, intvec(w[i],j) ); }
     }
  }
  //   Make the coordinate ring.  The name R is internal to this proceduire
  string ringConstructor = "ring R = " + #[1] + ",(" ;
  for ( i=1; i<=size(indsOfVariables); i++ )  {
    pr = indsOfVariables[i];
    if ( i>1 ) { ringConstructor = ringConstructor + ","; }
    ringConstructor =  ringConstructor + #[2] + "(" + string(pr[1]) + ")" + "(" + string(pr[2]) + ")";
  }   
  ringConstructor = ringConstructor + ")," + #[3] + ";";
  execute(ringConstructor);

  matrix locCoordinats[2*n][n];

  for (j=1; j<=n; j++) { locCoordinats[wc[j],j] = 1; }
  for ( i=1; i<=size(indsOfVariables); i++ )
  {
    pr = indsOfVariables[i];
    locCoordinats[pr[1],pr[2]] = var(i);
  }
  //  Finds the indices of dependent entries in Stiefel coordinates for the Lagrangian Grassmannian
  for (j=2; j<=n; j++)
  {
     for (i=1; i<=j; i++)
     {
        if (w[i] < w[j] and w[i] < wc[j])
        {
          locCoordinats[w[i],j] = locCoordinats[w[j],i];
	  if (w[j]>n) { locCoordinats[w[i],j] = -1 * locCoordinats[w[i],j]; }
        }
     }
  }
  string coordConstructor = "matrix " + #[4] + " = locCoordinats ;";
  execute(coordConstructor); 
  string exportConstructor = "export( " + #[4] + " );";
  execute(exportConstructor);
  return( list(R, #) );
}
example
{
  "EXAMPLE:"; echo = 2;
  list myRingData = "0", "y", "dp", "myCoordinates";
  def myRing = makeLagrangianCoordinates( w , myRingData)[1];
  setring myRing;
  print(myCoordinates);
}
////////////////////////////////////////////////////////////////////////////////////////////////////

// &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Makes the symplectic flag osculating the rational normal curve
//   transpose( 1, t, t^2/2!, ... , t^(2n-1)/(2n-1)! ) , where positions n+1, n+3, ... are negated.
//  This gives an isotropic flag
//
proc osculatingFlagC ( int n, poly t)
"USAGE: osculatingFlagC ( n, t )

   Computes the isotropic flag osculating the rational normal curve for our given symplectic form internalJ:
   transpose( t^(2n-1)/(2n-1)! , ... , t^2/2!, t, 1 ) , where positions n, n-2, ... negated.

 RETURN: The 2n x 2n matrix F(t) representing the osculating isotropic flag 
 NOTE:    Requires a basering.  When t=0, the osculating flag is the coordinate flag opposite to the standard flag.
           This may cause issues with local coordinates of Richardson varieties
 EXAMPLE: example osculatingFlagC shows an example"
{
  int i,j;
  matrix M = osculatingFlag(2*n, t);
  for (i=1; i<=n; i = i+2) 
  {
    for (j=1; j<=2*n; j++)
    {
      M[n+1-i,j] = -1 * M[n+1-i,j];
    }
  }
  return(M);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Computes a random symplectic flag with integer entries; the initial entries are in 
//    -range ..  range
//
//   Need more instructions here.  characteristic, default range, parameters, etc.
//
//
proc randomFlagC ( list # )
"USAGE: matrix F = randomFlagC (  [n, range] ) or  matrix F = randomFlagC( [ n ] )
  Creates a random invertible 2n x 2n symplectic matrix
  In characteristic p > 0, the free entries are uniformily chosen random integers between 1 and p.
  In characteristic 0, they are rational numbers a/b where a is a random integer in -range...range and b in 1..range.
      With one entry, range is set to 100.
 RETURN: The random flag
 NOTE: This requires a basering to be active
 EXAMPLE: example randomFlagC shows an example"
{
  if (size(#)==0 or size(#)>2) { print("incorrect input for randomFlag");  quit; }

  int n = #[1];
  int i,j,ii, range;
  matrix myJ,M;
  poly pairing;

  if (size(#)==1)
  {
    #[2] = 100;
  }
  range = #[2];

  // Start with a random flag
  M =  randomFlag( list( 2*n, range) );
  // make it triangular and set some entries to zero
  for (i=1; i<=2*n; i++)
  {
    M[i,i] = 1;
    for (j=i+1; j<=2*n; j++)
    {
      M[i,j] = 0;
    }
    for (j=i+1; j<=2*n-i; j++)
    {
      M[2*n+1-i,j] = 0;
    }
  }
  // fill in the missing entries to make it an isotropic flag with respect to the internal matrix J
  for (i=n; i>0; i--)
  {
    for (j=i+1; j<=2*n-i; j++)
    {
      pairing=0;
      for (ii=1; ii<=n; ii++)
      {
        pairing = pairing - M[ii,i]*M[2*n+1-ii,j] + M[ii,j]*M[2*n+1-ii,i];
      }
      M[2*n+1-i,j]=pairing;
    } 
  }
  return( M );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   This makes the matrix J of the (anti-diagonal) symplectic form that we use
//
proc internalJ( int n)
"USAGE: internalJ( n )

   Computes the skew-symmetric 2n by 2n matrix J representing the symplectic form that we are using for type C Schubert calculus

 RETURN: The 2n x 2n matrix J

 EXAMPLE: example internalJ shows an example"
{
  intmat J[2*n][2*n];
  for (int i=1; i<=n; i++)
  {
    J[  i,2*n+1-i]=-1;
    J[n+i,  n+1-i]= 1;
  }
  return( J );
}
example
{
  "EXAMPLE:"; echo = 2;
  print(internalJ( 3 ));
}
////////////////////////////////////////////////////////////////////////////////////////////////////

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//
//  Static procedures below
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   Internal (static) procedures Not needed for export
//
//
// proc isPartialPermutation( intvec w )
//        tests if w is a partial permutation.  1 = yes and 0 = no
//
// proc belongsTo (int d, intvec a)   returns a boolean 0 or 1
//        Checks if integer d is a component of vector a
//
// proc isCondition (intvec w, intvec flagType)
//    Checks if partial permutation w is a Schubert condition for the flag manifold of type flagType
//
// proc indicesOfVariables ( intvec flagType , list conditions )   This helper function
//      returns a list of pairs which are the positions of the variables in the type A Stiefel coordinates.
//      This is a helper function for makeStiefelCordinates
//
// proc jumps (intvec condition)  Fnds the positions of the essential conditions (jumps) in the Schubert
//          condition for a classical Grassmannian
//
// proc getDescents (intvec w)
//        Gets the descent set of a partial permutation w in type A. 
//
// proc completeToPermutation ( intvec w, int n ) returns an intvec (a permutation)
//      Completes a partial permutation w to a full permutation in S_n or breaks
//
//   The next three may be missing input checks ans examples
//
// proc  plueckerStep( intvec w, int n )
//      Computes one step in the lexicographic walk through  Pluecker indices on the Grassmannian Gr( len(w), n )
//
// proc plueckerIndices( int k, int n )
//    Computes the list of all Pl\"ucker indices for  on the Grassmannian Gr(k,n), in lexicoigraphic order
//    This is a helper function for computing the minimal equations for Schubert varieties.
//
// proc plueckerVector ( list plIndices, matrix myMatrix )
//    Computes the Pluecker vector of the n\times k matrix myMatrix w.r.t. the given set plIndices of Pluecker indices
//
// proc dualIndex( intvec w, int n )
//     Computes the dual Pluecker index to w (with k rows) for Grass(k,n)
//
// proc  leqPluecker( intvec firstIndex, intvec secondIndex)
//     Computes the Boolean firstIndex \leq secondIndex in Bruhat Order on Grassmannian
//
// proc allNotLessThan( intvec w, int n, list pIndices)
//     Computes all Pluecker indices from pIndices for Gr(k,n)  that are not less than w
//
///// &&&&&&&&&&&&&&&&&&&&&&&&&&&&    Type C  helper routines
//
// proc isPartialPermutationC( intvec w, int n )
//      Tests if w is a partial permutation in the Weyl group C_n, returning a boolean
//
// proc isLagrangianCondition ( intvec w )
//     Tests if w is a condition for the Lagrangian Grassmannian
//
//

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   This tests if w is a partial permutation.  1 = yes and 0 = no
//
proc isPartialPermutation( intvec w )
"USAGE:  isPartialPermutation( w );  w intvec
   
 RETURN: int: 1 if the integer vector is a partial premutation in that it has distinct positive entries.
              0 if it is not a partial permutation.
   
 EXAMPLE: example isPartialPermutation; shows an example"
{
  intvec u = sort(w)[1];
  if (u[1] < 1) { return( 0 ); }
  for (int i=1; i<nrows(u); i=i+1) {
   if (u[i] == u[i+1]) { return( 0 ); } 
  }
  return( 1 );
}
example
{
  "EXAMPLE:"; echo = 2;   
  isPartialPermutation( intvec( 1, 4, 3, 7 ) );
  isPartialPermutation( intvec( 1, 4, 3, 4 ) );
  isPartialPermutation( intvec( 1,-1, 3, 4 ) );
}
// should get the values 1, 0, 0 from these inputs
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Checks if integer d is a component of vector a, returning a boolean 1/0    
//
//   This is static and not exported
//
proc belongsTo (int d, intvec a)
"USAGE:  belongsTo(d, a);  d int, a intvec

 RETURN: int: 1 if d is a component of a  and  0 if it is not
 
 EXAMPLE: example belongsTo; shows an example"
{
  for (int i=1; i<=nrows(a); i++) {
    if (d==a[i]) { return(1) }
  }
  return(0);
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec myFlagType = 2,3,5;   
  int d = 3;   
  belongsTo(d, myFlagType);   
} 
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Checks if partial permutation w is a Schubert condition for the
//     flag manifold of type flagType                                                             
//
proc isCondition (intvec w, intvec flagType)
"USAGE:  isCondition( w, flagType);  w intvec, flagType intvec
   
 RETURN: int: 1 if the partial permutation w has descents in the set flagType
              0 if not, including if it is not a partial permutation.
	This is the requirement that w is a Schubert condition for the flag variety
              encoded by flagType
   
 EXAMPLE: example isCondition; shows an example"
{
  int fits = isPartialPermutation( w ) * belongsTo(nrows(w), flagType);
  if (fits==1)
  {
    for (int i=1; i<nrows(w); i++)
    {
      if (w[i]>w[i+1]) { fits = fits * belongsTo(i,flagType); }
    }
  }
  return( fits );
} 
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  intvec flagType = 2, 3, 5;   
  isCondition(w, flagType);   
  isCondition(intvec(1,4), flagType);   
  isCondition(intvec(1,4,3), flagType);   
}
// should get the values 1, 1, 0 from these inp[uts
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This is a helper function for making Stiefel coordinates in type A.  It returns a list of indices of the 
//    variables in the Stiefel coordinates w.r.t. the standard coordinate flag.
//      
//  This is typically called with a flagType and a list of a single condition w and 
//    returns data for Steifel coordinates for a Schubert cell X_w, but
//    if the flagType is a Grassmannian, there may be two conditions and it will  
//    return Stiefel coordinates for a Richardson variety.
//
//  This is an internal procedure and will not be exported.
//
//    Does not yet check that the Schubert condition fits the flagType
//
proc indicesOfVariables ( intvec flagType , list conditions )
"USAGE:  list L =indicesOfVariables( flagType, conditions); 
      flagType describes the type of the flag manifold
      conditions is a list of one to two  permutations for flagType that describe the Stiefel coordinates
             (two only when flagType is a Grassmannian)

 RETURN: a list of integer vectors of length 2. 
   
 EXAMPLE: example indicesOfVariables; shows an example"
{
  if ( size(conditions)>2  or size(conditions)==0 )
  {
    printf("Input failure, Stiefel Coordinates requires at most two conditions.  You inputted %s.", size(conditions));
    quit;
  }
  if (not isCondition( conditions[1], flagType))
  {
    printf("Input failure, (%s) is not a Schubert condition for the flag variety (%s).", conditions[1], flagType);
    quit;
  }
  int a,i,j;
  int n = flagType[nrows(flagType)];
  list indicesOfVariables = list();
  //  Finds the indices of variables in type A Stiefel coordinates, in the case when there is one Schubert condition
  intvec w = conditions[1];
  if (size(conditions) == 1)
  {
    intvec extendedFlagType = intvec(0), flagType;
    for (a=1; a<nrows(flagType); a++)
    {
      for (j=extendedFlagType[a]+1; j<=flagType[a]; j++)
      {
        for (i=1; i<=n-w[j]; i++)
        {
          if (not belongsTo(n+1-i , intvec(w[1..flagType[a]])) )
          {
            indicesOfVariables = insert( indicesOfVariables, intvec(i,j) );
          }
        }
      }
    }
    return( indicesOfVariables );
  }
 else
  //   If there are two Schubert conditions, then we must be on a Grassmannian
  {
    if (nrows(flagType) > 2)
    {
      printf("Input failure for flagType = intvec (%s), conditions = list ( intvec (%s), intvec (%s) ) :",
                flagType, conditions[1], conditions[2]);
      printf("The flag variety is not a Grassmannian, as flagType = (%s), and the Richarson variety",flagType);
      printf("option requires a Grassmannian.");
      quit;
    }
     if (not isCondition( conditions[1], flagType))
    {
      printf("Input failure, (%s) is not a Schubert condition for the flag variety (%s).", conditions[2], flagType);
      quit;
    }
    intvec v = conditions[2];
    int k = flagType[1];
    for (j=1; j<=k; j++)
    {
      if ( n+1 < w[j] +v[k+1-j] )
      {
        printf("Input failure  for flagType = intvec (%s), conditions = list ( intvec (%s), intvec (%s) ) :",
                 flagType, conditions[1], conditions[2]);
        printf("The conditions (%s) and (%s) define an empty Richardson variety",w,v);
        quit;
      }
      for (i=v[k+1-j]; i<=n-w[j]; i++)
      {
        indicesOfVariables = insert( indicesOfVariables, intvec(i,j) );
      }
    }
    return( indicesOfVariables );
  }
}
example   
{   
  "EXAMPLE:"; echo = 2;
  intvec myFlagType =  2, 3, 6;
  intvec w = 2,6, 4, 1,3,5;
  list myConditions = w ;
  list L  = indicesOfVariables( myFlagType, myConditions );
  print(L[1]);
  print(L[2]);
} 
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This finds the positions of the essential conditions in a Scbubert condition for the classical Grassmannian
//
proc jumps (intvec condition)
"USAGE: intvec essC = jumps( w )
  w is a partial permutation
 RETURN: The vector of positions i where w[i-1] + 1 < w[i] (w[0]=0)  --- the essential Conditions
 EXAMPLE: example jumps shows an example"
{
  intvec w = sort(condition)[1];
  intvec jmps;
  int i,val;
  val=0;
  for (i=1; i<=nrows(w); i++) 
  {
    if (val+1 < w[i]) 
    {
      jmps= jmps, i;
    }
    val = w[i];
  }
  return(intvec(jmps[2..nrows(jmps)]));
}
example   
{   
  "EXAMPLE:"; echo = 2;
  jumps(intvec(1, 2, 4, 6));
} 
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Gets the descent set of a partial permutation w.                                              //
//
proc getDescents (intvec w)

"USAGE:  getDescents( w );  w intvec
 RETURN: The integer vector whose components are the descent set { i : w[i]>w[i+1] } of w.
 NOTE: This does not check that w is a partial permutation, but it does complete it to a permutation.
 EXAMPLE: example getDescents; shows an example"
{
  if ( isPartialPermutation( w )<>1 )
  {
    print("Input (%s) to getDescents is not a partial permutation.",w);
    quit;
  }
  intvec descents;
  intvec u = sort(w)[1];
  int n = u[nrows(w)];
  u = completeToPermutation( w, n );
  for (int i=1; i<=nrows(u)-1; i++) {
    if (u[i]>u[i+1]) { descents = descents , intvec(i) ; }
  }
  if (nrows(descents)>1) {descents = descents[2..size(descents)];}
  return ( descents );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 3,5, 1,6, 2,7;   
  getDescentsA( w );
}
//   The result should be 2, 4, 6
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Completes a partial permutation w to a full permutation for S_n                               //
//
proc completeToPermutation ( intvec w, int n )
"USAGE:  intvec w = completeToPermutation( w, n);  w intvec, n int
   
 RETURN: The full permutation in S_n whose initial values agree with w, and remaining values are increasing.

 EXAMPLE: example completeToPermutation; shows an example"
{
  if ( isPartialPermutation(w) <>1 )
  {
    printf("Input failure for completeToPermutation ( intvec (%s), int %s ) :",w, n);
    printf("The vector (%s) is not a partial permutation.",w);
    quit;
  }
  if ( nrows(w) < n )
  {
    for ( int i=1; i<=n; i++ )
    {
      if (belongsTo(i,w)==0) { w = w, intvec(i); }
    }
  }
  return ( w );
}
example   
{   
  "EXAMPLE:"; echo = 2;   
  intvec w = 1,4,3;   
  int n = 5;   
  completeToPermutation(w, n);   
}
//   The result should be 1,4,3,2,5
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Computes one step in the lexicographic walk through Pluecker indices on a Grassmannian
//
proc plueckerStep( intvec w, int n )
"USAGE: intvec u = plueckerStep( condition, dimension ); 

  condition is a Schubert condition/Pluecker index for the Grassmannian Gr( nrows(w), dimension), 
        an increasing sequence of integers in [1, dimension]

 RETURN: The next index of a Pluecker coordinate for Gr( nrows(u), dimension) in lexicographic order,
          or the intvec (0) if the w was the maximal Pluecker index

 EXAMPLE: example plueckerStep shows an example"
 {
  int k = size(w);
  //          Check  if the input is valid  (this was tested)
  intvec sw = sort(w)[1];
  if (isPartialPermutation( w ) <> 1  or sw <> w or sw[k]>n )
  { 
    printf("Input failure for plueckerStep ( intvec (%s), int %s ) :", w,n);
    printf("The vector (%s) is not a Schubert condition for Gr(%s,%s).",w,k,n);
    quit;
  }
  //       returns (0) if w was the largest Pluecker index
  if ( w[1] == n+1-k ) { return( intvec(0) ); }
  //
  for (int i=1; i<=k; i=i+1)
  {
     if (w[k+1-i] < n+1-i) {break;}
  }
  int old = w[k+1-i];
  for (int j=i; j>=1; j=j-1)
  {
    w[k+1-j] = old+i+1-j;
  }
  return( w );
 }
 example   
 {
   "EXAMPLE:"; echo = 2;   
   intvec w = 1,5,6;   
   int n = 6;   
   plueckerStep(w, n);   
 }
//   The result should be 2,3,4
///////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Computes the list of n choose k Pluecker indices on a Grassmannian
//
//   Need to check that k < n
//
proc plueckerIndices( int k, int n )
"USAGE: list L = plueckerIndices( k, n );   int k,  int n

  RETURN: The complete list of all Grassmannian Schubert condition for Gr( k , n )) in lexicographic order.
           This is to  generate equations for Schubert varieties
 
  NOTE: This is for the Grassmannian Gr( k , n ) 

 EXAMPLE: example plueckerIndices shows an example"
 {
  intvec w = 1..k;
  list L=list(w);
  while (1)
   {
    w  = plueckerStep(w,n);
    if (not w[1]) {break;}
    L = insert(L,w,size(L));
   }
  return(L);
 }
 example
 {
   "EXAMPLE:"; echo = 2;   
   plueckerIndices( 2 , 4 );
 }
//   The result should be [ [1,2], [1,3], [1,4], [2,3] [2,4], [3,4] ]
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This takes a pair of a list of indices (n choose k) and a n x k matrix myMatrix and returns
//   the list of Pluecker vectors of myMatrix.
//
//  Warning:  This internal procedure assumes that the first list is indeed the set n choose k,
//              and the matrix has given format.  It provides no checks, assuming that the parent
//              procedure performs the check.
//
//  Missing checks and example
//
//
proc plueckerVector ( list plIndices, matrix myMatrix )
"USAGE: list L = plueckerVector( plIndices, myMatrix )

   This takes a pair of a list of indices (n choose k) and a n x k matrix myMatrix

  Warning:  This internal procedure assumes that the list is a list of k element subsets of row indices of myMatrix,
                and that myMatrix has k columns. It provides no checks, assuming that the parent
                procedure performs the check.

 RETURN: The list of Pluecker vectors of myMatrix with indices in plIndices

 EXAMPLE: example plueckerVector shows an example"
{
  list plCoords = list();
  int k = nrows(plIndices[1]);
  for (int i=1; i<=size(plIndices); i++)
  {
    plCoords = insert(plCoords, det(submat(myMatrix,plIndices[i],1..k)), i-1);
  }
  return(plCoords)
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Computes the dual Pluecker index to w for Grass (k, n)
//
//  Needs checks, documentation, and example
//
proc dualIndex( intvec w, int n )
{
  intvec dualCondition;
  int k = size( w );
  for (int i=1; i<=k; i++)
  {
    dualCondition[i]=n+1-w[k+1-i];
  }
  return(dualCondition)
}
example   
{   
  "EXAMPLE:"; echo = 2;
   intvec w = 1,2,5;
   int n = 7;
   dualIndex( w, n );
}
// should get 3,6,7
////////////////////////////////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Computes the Boolean that firstIndex \leq secondIndex in the Bruhat order on the Grassmannian
//
//   Need to check that they are both Pluecker indices for the same Grassmannian
//
proc  leqPluecker( intvec firstIndex, intvec secondIndex)
{
  int k = nrows(secondIndex);
  if (nrows(firstIndex) <> k )
  {
    print("Incompatible inputs to leqPluecker.  They need to have the same length")'
    quit;
  }
  int comparable = 1;
  for (int i=1; i<=k; i++)
  {
    comparable = comparable * ( firstIndex[i] <= secondIndex[i]);
  }
  return(comparable)
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Computes all Pluecker indices from pIndices for Gr(k,n)  that are not less than w
//
//   Needs documentation and example
//
//
proc allNotLessThan( intvec w, int n, list pIndices)
{
  int i;
  int k = nrows( w );
  intvec dualCondition = dualIndex( w, n );
  list L;
  for (i=1; i<=size(pIndices); i++)
  {
    if (not leqPluecker(pIndices[i], dualCondition))
    {
      L = insert( L, pIndices[i]);
    }
  }
  return(L);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
///// &&&&&&&&&&&&&&&&&&&&&&&&&&&&    Type C  helper routines     &&&&&&&&&&&&&&&&&&&&&&&&&&&&//////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Tests if w is a partial permutation in the Weyl group C_n
//
proc isPartialPermutationC( intvec w, int n )
"USAGE:  isPartialPermutationC ( w, n );    w intvec, n int
RETURN: int: 1 if w is a partial permutation in C_n in that it has distinct entries in [1, 2n],
                and no two sum to 2n+1
             0 if it is not in C_n
EXAMPLE: example isPartialPermutationC; shows an example"
{
  int i,j;
  int m = nrows(w);
  intvec u = sort(w)[1];
  if (u[1] < 1 or u[m]>2*n) { return(0==1); }
  for (i=1; i<m; i++)
  {
    if (u[i]==u[i+1]) { return(0); }
    for (j=i+1; j<=m; j++)
    {
      if (u[i]+u[j] == 2*n+1) { return(0==1); }
    }
  }
  return( 1==1 );
}
example
{
  "EXAMPLE:"; echo = 2;
  isPartialPermutationC ( intvec(1, 5, 3), 3 );
  isPartialPermutationC ( intvec(1, 5, 3), 4 );
  isPartialPermutationC ( intvec(1, 4, 5), 4 );
}
//  Answers should be  1 1 0
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  checks that w is a condition for the Lagrangian Grassmannian
//
proc isLagrangianCondition ( intvec w )
"USAGE:  isLagrangianCondition ( w );   w intvec
RETURN: int: 1 if w is a Schubert condition for the Lagrangian Grassmannian in that if n=nrows(w),
               then w is a partial permutation in C_n and is increasing order
             0 otherwise
EXAMPLE: example isLagrangianCondition; shows an example"
{
  int n = nrows( w );
  intvec u = sort(w)[1];
  if (u<>w) { return(0); }
  return( isPartialPermutationC( w, n) );
}
example
{
  "EXAMPLE:"; echo = 2;     
   isLagrangianCondition( intvec(1,5,4) );
   isLagrangianCondition( intvec(1,3,5) );
}
// Should get 0 1
////////////////////////////////////////////////////////////////////////////////////////////////////


